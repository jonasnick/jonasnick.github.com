<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: bitcoin | nickler's]]></title>
  <link href="http://jonasnick.github.io/blog/categories/bitcoin/atom.xml" rel="self"/>
  <link href="http://jonasnick.github.io/"/>
  <updated>2015-04-27T12:24:09+02:00</updated>
  <id>http://jonasnick.github.io/</id>
  <author>
    <name><![CDATA[Jonas Nick]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Evaluating Satoshi's Clustering Heuristic]]></title>
    <link href="http://jonasnick.github.io/blog/2015/03/27/evaluating-satoshis-clustering-heuristic/"/>
    <updated>2015-03-27T12:47:00+01:00</updated>
    <id>http://jonasnick.github.io/blog/2015/03/27/evaluating-satoshis-clustering-heuristic</id>
    <content type="html"><![CDATA[<p>In a <a href="/blog/2015/02/12/privacy-in-bitcoinj/">previous post</a> I showed that once an attacker captures a Bloom filter of a BitcoinJ powered wallet from the P2P network
he can find out all public keys this wallet contains with very high probability.
<a href="http://www.disco.ethz.ch/members/cdecker.html">Christian Decker</a> and I have collected the pubkeys contained in more than 70,000 Bloom filters.
We are very interested in privacy aspects of bitcoin, so we see this as a unique opportunity to evaluate Satoshi&rsquo;s classic clustering heuristic: all inputs of a transaction belong to the same owner.</p>

<p><blockquote><p>Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner.<br/>The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.</p><footer><strong>Satoshi Nakamoto</strong> <cite>Bitcoin: A Peer-to-Peer Electronic Cash System</cite></footer></blockquote></p>

<p>So for each wallet and for each contained pubkey we recursively apply the heuristic to all transactions the pubkey occurs in.
There have been a few academic publications on this matter such as <a href="http://eprint.iacr.org/2012/596.pdf">Androulaki et al. 2013</a> and <a href="http://cseweb.ucsd.edu/~savage/papers/IMC13.pdf">Meiklejohn et al. 2013</a>.
Also, there are some online tools and companies that allow exploiting this property of bitcoin: <a href="https://bitiodine.net/">bitiodine</a>, <a href="http://coinalytics.co/">coinalytics</a> and <a href="http://www.walletexplorer.com/">walletexplorer</a>.</p>

<p>But so far nobody had access to a collection of actual wallets in order to evaluate the performance of the heuristic.
Thus, previous statements and conclusions were either based on simulations (Androulaki et al.) or relied on intuitions.</p>

<p>We expect that the probability that a pubkey that was found with the heuristic really belongs to the wallet (<strong>precision</strong>) is close to 1 because this is how all standard wallets create transactions.
Countermeasures against this are <a href="https://bitcointalk.org/index.php?topic=139581.0">coinjoin transactions</a> which certainly do not require that &ldquo;entities would need to reveal their private keys to each other&rdquo; (Meiklejohn et al. 2013).
However, what we are really interested in is the <strong>recall</strong> &ndash; the percentage of the wallet&rsquo;s pubkeys an attacker learns given he knows one pubkey &ndash; and how we can improve it.</p>

<p><strong>tl;dr:</strong> As expected, the probability that a pubkey really belongs to the same entity (precision) is very high &hellip; whereas the amount of pubkeys that we can find (recall) is surprisingly small. We show a simply tweak that can improve the recall significantly.</p>

<!-- more -->


<h2>Data</h2>

<p>Computing a wallet&rsquo;s pubkeys given the captured bloom filter takes about 1 hour.
But thanks to ETH Zurich&rsquo;s computing clusters and Christian Decker&rsquo;s blockchain analysis infrastructure we could compute the collection of 70,078 wallets in a few weeks.</p>

<p><strong>WRITE NUMBER OF CLUSTERS before and after removal</strong></p>

<p>In order to remove duplicates, we grouped wallets which have a pubkey in common such that only the one with the most pubkeys remains.
The set of the wallet&rsquo;s useragents is quite diverse</p>

<p><strong>WRONG because this is before duplicate removal</strong></p>

<table>
<thead>
<tr>
<th></th>
<th> Useragent         </th>
<th> Count      </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Bitcoin Wallet    </td>
<td> 48313 </td>
</tr>
<tr>
<td></td>
<td> Multibit          </td>
<td> 15125</td>
</tr>
<tr>
<td></td>
<td> KnC               </td>
<td> 659</td>
</tr>
<tr>
<td></td>
<td> Hive              </td>
<td> 518</td>
</tr>
<tr>
<td></td>
<td> Green Wallet      </td>
<td> 127</td>
</tr>
<tr>
<td></td>
<td> breadwallet       </td>
<td> 84</td>
</tr>
<tr>
<td></td>
<td> others            </td>
<td> 5252</td>
</tr>
</tbody>
</table>


<p>For our analysis we choose to select only Bitcoin Wallet, Multibit (non-HD), KnC and Hive and omit the more obscure wallets.
Everybody who has worked with the blockchain knows that it is a strange place where all sorts of things can happen. Only a single pubkey erroneously included in the cluster can lead to giant superclusters.</p>

<p>We have learned from the previous post that there is still a chance (false positive rate) that we wrongly associate a pubkey with a wallet.
A wallet using BitcoinJ version newer than 0.12 (which introduced hierarchical deterministic wallets) typically has a false positive rate around 0.000146, which would result in around 1.3 expected false positive pubkeys per wallet.
Unfortunately, a single false positive per wallet can already vastly destroy the accuracy of our analysis, so we have to select wallets with a much lower false positive rate.
We decide to require a false positive rate smaller than 0.00001, which leads to an expected total number of false positives in <em>all</em> wallets of <em>0.31</em>.
This is because BitcoinJ wallets older than 0.12 mostly have extremely small false positive rates and surprisingly BitcoinJ &lt; 0.12 is still widely deployed.
We end up with 20,765 wallets.
<strong>WRONG because we have to select the ones that also remain after duplicate removal!</strong>
One should note that most android bitcoin wallets have only a single pubkey because before HD wallets it was a pain to create a new pubkey.</p>

<p>//
// is there a correlation between wallet size and fp rate: yes! and it&rsquo;s significant, but in the graph we can&rsquo;t see anything
// we only have a small amount of clusters yet
// show histogram for all cluster sizes for user agents!
// show histogram for clusters sizes for fp rate filtered
// with limited data there is a huge difference
// show plot fp_rate vs. num pubkeys
We do have to carefully investigate that a selection does not introduce a strong bias in the wallets.</p>

<p>Regarding the data we have to state some facts very clearly.
We assume that the fraction of filters that include public keys that are not in the wallet is negligible.
&lsquo;Poisened&rsquo; filters could be deliberately broadcasted by some nodes to thwart analyses like ours.
Similarly, watch-only addresses also entail inclusion into the filter even though the private key is not owned by the wallet.
However, none of the selected useragents implements a watch-only feature and a small fraction of poisened filters does not influence
the analysis very much since each wallet has the same influence on the performance metric.</p>

<p>Also, our data comprises <em>only</em> BitcoinJ wallets, which might have a different coin selection policy than other wallet software.
When composing transactions BitcoinJ minimizes fees whereas for example Bitcoin Core minimizes change.
More specifically, because we selected the aforementioned useragents we can only account for the particular spending habits of people using
these wallet softwares.
* HD wallets have better privacy</p>

<h2>Evaluation</h2>

<p>In order to evaluate the performance of the heuristic we use standard performance metrics for binary classification: precision and recall.
Precision can be understand as the probability that a pubkey $p'$ is owned by a wallet given that it was found by applying heuristic $H$ to some other pubkey $p$ of the wallet.
of the user $\text{prec(p)} = P(O(p') | p' \in H(p))$. Similarly, recall can be seen as the probability that a pubkey $p'$ will be found by the heuristic given that it belongs to the the wallet $\text{rec(p)} = P(p' \in H(p) | O(p'))$. In order to obtain final metrics we average over all pubkeys of a wallet and all wallets.</p>

<p>In detail, let $W$ be our collection of $n$ wallets where each $w_i \in W$ is a set of pubkeys, then we have</p>

<p>$\text{prec(W)} = \frac{1}{n} \sum_i \frac{1}{|w_i|} \sum_{p\in w_i} \frac{w_i \cap H(p)}{|H(p)|}$ and</p>

<p>$\text{rec(W)} = \frac{1}{n} \sum_i \frac{1}{|w_i|} \sum_{p\in w_i} \frac{w_i \cap H(p)}{|w_i|}$.</p>

<ul>
<li>table read db and average, confidence interval, standard deviation per wallet</li>
<li>make graph for size of wallet</li>
</ul>


<h2>Tweaking</h2>

<p>Christian Decker came up with a heuristic we have not seen mentioned anywhere before:
If there is a unique output with a smaller value than any of the inputs then this has to be the change address.
Combined with Satoshi&rsquo;s heuristic we get&hellip;
* decker&rsquo;s heuristic</p>

<h2>Conclusion</h2>

<p>If you have ideas for additional tweaks you want to see evaluated feel free to contact me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitcoin Seeder DoS vulnerability]]></title>
    <link href="http://jonasnick.github.io/blog/2015/03/17/bitcoin-seeder-dos-vulnerability/"/>
    <updated>2015-03-17T22:23:00+01:00</updated>
    <id>http://jonasnick.github.io/blog/2015/03/17/bitcoin-seeder-dos-vulnerability</id>
    <content type="html"><![CDATA[<p>The DNS parser of the <a href="https://github.com/sipa/bitcoin-seeder">Bitcoin Seeder</a> was vulnerable to a denial of service attack. A specially crafted DNS request could trigger infinite recursive function calls that lead to a stack overflow. See the <a href="https://gist.github.com/jonasnick/62558e4b8ab43bc847c2">exploit</a>.
The vulnerability was fixed in commit <a href="https://github.com/sipa/bitcoin-seeder/commit/11e935b72020607e5c3ce85a88209bc34e427a06">11e935b</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guessing bitcoin's P2P connections]]></title>
    <link href="http://jonasnick.github.io/blog/2015/03/06/guessing-bitcoins-p2p-connections/"/>
    <updated>2015-03-06T14:22:00+01:00</updated>
    <id>http://jonasnick.github.io/blog/2015/03/06/guessing-bitcoins-p2p-connections</id>
    <content type="html"><![CDATA[<p>The paper <a href="http://arxiv.org/abs/1405.7418">Deanonymisation of clients in Bitcoin P2P network (2014)</a> by Biryukov, Khovratovich and Pustogarov (BKP), who describe an attack on Bitcoin Core clients, has started some discussion lately.
The main idea of the paper is to first get a set of nodes $E_v$ to which your victim $v$ is directly connected to (&ldquo;entry nodes&rdquo;).
Second, for each transaction $t$ record the $10$ nodes $P_t$ which first propagate $t$.
The authors experimentally show that if $|E_v \cap P_t|$ is bigger than $3$ then there is a pretty high chance that $t$ actually originated from $v$.
However, both attack stages basically require a Sybil attack &ndash; the attacker has to be connected to a lot of nodes a lot of times.
&lsquo;A lot&rsquo; means that in their experiments they had 50 connection to each full node (~250) in the test network.
As a result, such an attack seems to be powerful, but certainly won&rsquo;t be undetected.</p>

<p>In this post I show that the first stage of the attack, namely learning the nodes a victim is directly connected to can
be done with a single connection to the victim.
In addition to BKP&rsquo;s attack, knowing all outbound peers of a client could significantly increase the success probability of a double spend.
Note that all experiments are based on Bitcoin Core 0.9.4, but 0.10.0 shows the same behavior.</p>

<p><strong>TLDR</strong> The attacker can reliably guess all of the outbound connections of a victim by making a selection from the known addresses of a victim based on the timestamp of the addresses.</p>

<p><strong>Update</strong> A <a href="https://github.com/bitcoin/bitcoin/pull/5860">fix has been merged</a> to bitcoind. The timestamp is not updated anymore when receiving a message from a connected peer. Instead, it is only updated when the peer disconnects. The fix is released in bitcoin core 0.10.1.</p>

<!-- more -->


<h2>Learning connections using addr propagation</h2>

<p>When a node $n$ connects to another peer $p$ in the network it advertises its address using the &ldquo;addr&rdquo; message.
The peer will select a number of its own peers at random which are &ldquo;responsible&rdquo; for $n$&rsquo;s address.
Then the address is forwarded to responsible peers to spread the knowledge about $n$ in the network.
The number of responsible peers is either $1$ or $2$ depending on whether the address is reachable by $p$.</p>

<p>BKP&rsquo;s attack works by recording the set of peers that first propagated a victim&rsquo;s address.
In order to have good chance to be in the set of responsible peers for the address, the attacker has to hold
a significant number of connections to each full node in the network.
Note that it is possible to have multiple connections from a single public address to a peer.</p>

<h2>The getaddr message</h2>

<p>It turns out that an attacker can simply infer the peers of a victim by sending getaddr messages to him.</p>

<p>In bitcoin, the address structures that are send via the addr message do not only contain the IP adress and port
but also a timestamp.
The timestamp&rsquo;s role is ensuring that terminated nodes vanish from the networks knowledge and it is regular refreshed by
the nodes which have an interaction (more about that later) with the peer at that address.
Bitcoin nodes usually record the addresses they hear about and send them in a reply to a getaddr using the addr message.</p>

<p>The following experiments show that an attacker can guess some or all of the direct peers of a victim
by sorting the known addresses of the victim based on the timestamp.</p>

<p>A minor obstacle is that a node replies to a single getaddr message only with maximal 2500 addrs selected uniformly at random.
In order to get a certain percentage $\tau$ of the known addresses of a node the attacker has to send multiple
getaddr messages and record the percentage that is new to her.</p>

<p>```
S = {}
while(true):</p>

<pre><code>send_getaddr()
T = response()
tau' = 1 - ((|T - S|) / |T|) 
S &lt;- S $\cup$ T
if \tau' &gt; \tau
    break
</code></pre>

<p>return S
```</p>

<p>Experiments show that if we wait 10 seconds after each getaddr request it takes around $3.5$ minutes to collect $\tau$ percent addresses ($13,500$ in this case).</p>

<h2>Experimental results</h2>

<p>I set up a victim node $v$, which is just a regular bitcoin node.
The attacker $a$ is a node that connects to $v$ via the P2P network and queries the known nodes of $v$.
Second, $a$ connects to $v$ via the RPC interface and gets the true peers.</p>

<p>The attacker code (btcP2PStruct) is <a href="https://github.com/jonasnick/btcP2PStruct">available on github</a>.
Thanks to the <a href="https://github.com/conformal/btcwire">btcwire</a> package it is very simple to write this kind of code.</p>

<p>You can find all the data to produce the graphs in the <a href="https://github.com/jonasnick/btcP2PStruct/data">project repository</a>.</p>

<p>First we consider the case where $v$ does not accept incoming connections (&ldquo;client&rdquo; in BKP&rsquo;s terms).
$v$ was running for 2 days and I recorded data for every hour but I will only discuss the last measurement
because the data is very similar.</p>

<div class="text-image-big">
<img src="http://jonasnick.github.io/images/guessing_btc_peers/client-histogram.png">
</div>


<p>Note that $v$ returned $12,868$ known addresses.
Also, a client usually has maximally 8 peers due to the default maximum number of outbound connections.
This implies that an attacker can not start start this attack on a client that is not connected to her.
Here we see that if the attacker obtains all peers of $v$ (without any false positives in this case).</p>

<p>Next, the case for the full node, which I left running for 8 days.</p>

<div class="text-image-big">
<img src="http://jonasnick.github.io/images/guessing_btc_peers/full_node-histogram.png">
</div>


<p>Again it is evident that an attacker can reliably determine all outbound connections of the victim using a threshold of 20 minutes.
However, inbound peers can only be detected very poorly.</p>

<p>The reason for finding all outbound peers is is <a href="https://github.com/bitcoin/bitcoin/blob/249bf0e0492758d71dc5d8fa77103b31b604979f/src/main.cpp#L4192">this logic in bitcoin-core</a> which refreshes the timestamp on every message of outbound nodes.</p>

<h2>Reducing false positives</h2>

<p>BKP mention a neat trick how to determine if two nodes $v_1$ and $v_2$ are connected.
First, the attacker connect to $v_1$ and $v_2$ and send addr messages containing bogus addresses to $v_1$.
Then, she counts the number of times one of these addresses is received from $v_2$.
However, the authors leave open how many messages you need send to be certain about the hypothesis.</p>

<p>As we already know, the address is forwarded only to two responsible nodes so we have to compute the
probabilities of our node being responsible.
Using the binomial distribution we can compute the likelihood of receiving a certain number of addresses back
given that we sent a certain number of addresses.</p>

<p>I&rsquo;ve done the math using <a href="https://github.com/jonasnick/btcP2PStruct/blob/master/prob/is_connected_prob.py">this code</a> and some assumptions regarding the structure (edges are uniformly iid).
Also, the attacker has to know or approximate the number of peers of a node, which can be done
with a similar method than the one described.
Connect two times to the victim, send and note the ratio of returned addr messages.
If you can not connect to the node, it will most likely have 8 peers.</p>

<p>This <em>theoretical</em> model shows that that if $v_1$ is a full node and $v_2$ is a client then we need about 2000 messages to determine if they are connected with 95% probability.
Similarly, if $v_1$ and $v_2$ are full nodes, the attacker needs to send 20000 messages.</p>

<p>However, in order to remain polite in the network this attack needs start from a candidate set of nodes.
Therefore, it could be a useful method to remove the false positives which were obtained with the &ldquo;getaddr&rdquo;-fingerprint.</p>

<h2>Conclusion</h2>

<p>It should be pointed out that even if you know a victim&rsquo;s entry nodes you can not simply connect to those few and listen for transactions.
This is because due to <a href="https://en.bitcoin.it/wiki/Satoshi_Client_Transaction_Exchange">&ldquo;trickling&rdquo;</a> it is not possible to estimate the origin of a transaction without further assumptions or doing BKP&rsquo;s Sybil attack.
However, knowing all outbound peers of a client could significantly increase the success probability of a double spend.</p>

<p><strong>Update</strong> The fix removes the update every 20 minutes and updates on disconnect</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Privacy in BitcoinJ]]></title>
    <link href="http://jonasnick.github.io/blog/2015/02/12/privacy-in-bitcoinj/"/>
    <updated>2015-02-12T15:53:00+01:00</updated>
    <id>http://jonasnick.github.io/blog/2015/02/12/privacy-in-bitcoinj</id>
    <content type="html"><![CDATA[<p>As part of my <a href="https://github.com/jonasnick/FCW-Kernel">epic quest</a> to apply supervised machine learning to the blockchain in order to discover transaction patterns, I reviewed various wallet implementations in the hope of finding privacy leaks.</p>

<p><strong>tl;dr</strong> If you are using a wallet that is built upon BitcoinJ, such as Android Wallet, Multibit and Hive Wallet, you have almost zero <em>wire privacy</em>.
An attacker who manages to connect to your wallet is easily able to figure out all addresses you control.
This is not very likely to get fixed in the near future.</p>

<p><strong>Update:</strong> <a href="https://groups.google.com/forum/#!msg/bitcoinj/Ys13qkTwcNg/9qxnhwnkeoIJ">Mike Hearn&rsquo;s reply</a> addresses additional problems and improvements.</p>

<!-- more -->


<h2>Bloom Filters for SPV Nodes</h2>

<p>A <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a> is a probabilistic data structure that is used to test whether an element is a member of a set.
Bitcoin SPV nodes that use <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">BIP 37</a> (we call them <em>thin clients</em> from now on) <code>put</code> all public keys they are interested in into the Bloom filter and send the filter to their peers. Upon receiving a new transaction, peers <code>query</code> the Bloom filter and only relay the transaction to the BIP 37 node if the query returned true.
Thus, thin clients normally only receive the transactions they are really interested in, i.e. mostly transactions that include one of the wallet&rsquo;s keys.</p>

<p>The advantage of using a Bloom filter instead of just broadcasting all your pubkeys is that a Bloom filter is faster and more space-efficient
at the cost of some <em>false positives</em>.
That means the thin client will receive transactions that include pubkeys which were not put into the filter.
Usually, the parameters of a Bloom filter are computed such that a certain target false positive rate (<code>fp</code>) is achieved.
We want the fp rate to be relatively small (say 0.05%) to reduce bandwidth usage.</p>

<h2>Bloom Filters and Privacy</h2>

<p>BIP 37 states:
<blockquote><p>Privacy: Because Bloom filters are probabilistic, with the false positive rate chosen by the client, nodes can trade off precision vs bandwidth usage. A node with access to lots of bandwidth may choose to have a high fp rate, meaning the remote peer cannot accurately know which transactions belong to the client and which don&rsquo;t.</p></blockquote></p>

<p>This has created a misunderstanding between what is ideally possible with Bloom filters and how the reality looks like.
I&rsquo;ll focus on BitcoinJ because it is the most widely used implementation of BIP 37, but similar vulnerabilities might exist in other implementations as well.
Unfortunately, in the current BitcoinJ implementation Bloom filters are just as bad for your privacy as broadcasting your pubkeys directly to your peers.</p>

<h2>A Simple Attack</h2>

<p>The main idea behind this vulnerability is that BitcoinJ puts both pubkey and pubkeyhash into the Bloom filter which substantially reduces the false positive rate.</p>

<p>If you create a completely fresh wallet, BitcoinJ holds 271 pubkeys and computes the parameters
of the Bloom filter such that the fp rate for (271*2)+100 elements is equal to 0.05%.
Because bitcoinj initially puts only 271*2 elements into the filter (pubkey and corresponding pubkeyhash) the effective false positive rate is <code>fp=0.000146</code>.</p>

<p>The vulnerability is that if a pubkey is truly in the filter then querying both pubkey and pubkeyhash must return true.
Because the pubkeyhash is just another almost uniformly random string, the probability of a false positive for the attacker is <code>fp' = fp^2 = 0.0000000021555</code>.
I obtained around 56 million pubkeys from the blockchain (mid-January), which theoretically results in <code>56 million * fp' = 1.29</code> expected false positives when scanning the blockchain.</p>

<h2>Experimental results</h2>

<p>I ran 20 crawlers since the beginning of December and collected 70,000 distinct filters until now.
These crawlers just listen for a filterload message and try to be really polite by disconnecting after 2 minutes and not sending anything.
The probability that a randomly selected DNS seed returns at least one of the crawlers is 4.3%.</p>

<p>In fact, most of the Bloom filters from recent BitcoinJ versions show a experimental false positive rate around 0.000146.
The experimental fp rate is computed by querying the filter with millions of elements which are certainly not pubkeys.
Android Wallet 4.16, 4.17, 4.18 for example use the most recent BitcoinJ version (12.2) and make up 52% of the data.
However, there is also MultiBit 0.5.18 whose effective fp rate is smaller than 0.00000001.</p>

<p>We are currently starting to analyze all filters using the described &ldquo;attack&rdquo; and we expect that this will take several weeks.
What we&rsquo;ve already seen is that the theoretical <code>fp'</code> really holds, i.e. if you create a fresh wallet and scan the whole blockchain you most likely get one false positive pubkey.</p>

<h2>(Slightly) More Difficult Attacks</h2>

<p>You might think that the problem is easily fixed by trading off bandwidth for more privacy and increase the fp rate to <code>fp = sqrt(0.0005) = 0.0224</code>.
On the one hand this might seriously impact the bandwidth of mobile clients, and on the other, there is another another general class of vulnerabilities concerning Bloom filters:
If an attacker manages to obtain multiple, different filters from the same Wallet,
he can compute the intersection of pubkeys that match the filters and therefore removes the false positive noise similar to the &ldquo;simple attack&rdquo;.
Different filters mean that they have different total size of a different Nonce.
Sending different filters can happen in BitcoinJ due to multiple reasons, for example</p>

<ul>
<li><em>Restart</em>. BitcoinJ stores the filter&rsquo;s nonce in volatile memory.</li>
<li><em>Creation of new keys</em>. When the wallet creates many new keys the filter gets &lsquo;full&rsquo; and thus has to be recomputed.</li>
<li><em>Measured false positive rate is too high</em>. BitcoinJ measures the false positive rate of transactions it receives. When it becomes too high the filter is recomputed.</li>
</ul>


<h2>Conclusion</h2>

<p>I do think this is a critical privacy leak as it doesn&rsquo;t require a sophisticated attack and wallets have practically been broadcasting all their pubkeys for years.
Not only the addresses you see in your wallet, but also a lot of your future addresses have been exposed.
From now on you should assume that the kind of bulk data collection I did is happening.
It is difficult to say how accurate and stealthy targeted attacks would be.</p>

<p>According to Mike Hearn, the creator of BitcoinJ, the problems have been known from the start but fixing these issues is far from trivial because &ldquo;lying consistently is hard&rdquo;.
I fully agree with this.
<strong>Someone needs to make it their project for a few months</strong>.</p>

<p>There are some simple ideas to slightly improve the current status such as <a href="https://twitter.com/petertoddbtc/status/559921997027610624">deploying nodes that broadcast fake bloom filters</a>.
<a href="http://www.syssec.ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/system-security-group-dam/research/publications/pub2014/acsac_gervais.pdf">Arthur Gervais et al., 2014</a> were the first to publish an academic paper on the topic and propose some more or less vague suggestions.
One idea I find interesting is that thin clients should be able to install multiple filters at their peers such that no pubkey is shared between the filters.
Thus, instead of recomputing the filter when the wallet creates new addresses, it would create an entirely fresh filter for the next keys.
One disadvantage is that at the moment multiple filters per peer is not supported by the bitcoin wire protocol.
Another issue with Bloom filters is that an attacker could safely assume that the probability is higher for two pubkeys to belong to the same person if they are closer in the transaction graph. As a countermeasure the wallet could deliberately put existing foreign pubkeys that are close into the filter.</p>

<p>I feel sorry for the people whose privacy has been potentially compromised unknowingly by malicious parties and we certainly won&rsquo;t give away the data set but nonetheless it is really exciting what can be found in the data.
If you have suggestions what to look out for and what would be interesting (not necessarily concerning machine learning) feel free to contact me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Evolving bitcoin trade bot]]></title>
    <link href="http://jonasnick.github.io/blog/2012/11/28/evolving-bitcoin-trade-bot/"/>
    <updated>2012-11-28T21:02:00+01:00</updated>
    <id>http://jonasnick.github.io/blog/2012/11/28/evolving-bitcoin-trade-bot</id>
    <content type="html"><![CDATA[<p><img src="/images/bagalute/index.png">
<a href="https://github.com/jonasnick/bagalute">Bagalute</a> is a trade bot, designed for buying a currency (bitcoin) at the the right time. As a decision criterium it uses the relative strength index (RSI). The bot looks at the price development of the last twelve hours and runs an evolutionary algorithm to determine the optimal parameters for the RSI in that time frame. Then, it uses these parameters for the next time frame. Currently the bot uses for debugging purposes a dummy interface to trade. The actual success of the bot was sparsely tested but had negative results, maybe due to a general downtrend of prices.
I wrote it during my 2nd semester break</p>
]]></content>
  </entry>
  
</feed>
